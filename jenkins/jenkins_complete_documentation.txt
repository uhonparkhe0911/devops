
JENKINS — Complete, Detailed Documentation for DevOps Engineers
----------------------------------------------------------------
Filename: jenkins_complete_documentation.txt
Generated: Comprehensive reference covering Jenkins concepts, architecture,
installation, administration, pipelines, plugins, security, scaling, examples,
troubleshooting, best-practices, and hands-on snippets for real-world DevOps.

TABLE OF CONTENTS (quick jump guide)
----------------------------------------------------------------
1.  Introduction & History
2.  Key Concepts & Terminology
3.  Architecture — Controller (Master) & Agents (Nodes)
4.  Installation & Production Deployment Options
5.  Core Components & Job Types
6.  Jenkins Pipelines (Declarative & Scripted)
7.  Pipeline Syntax Reference & Examples
8.  Shared Libraries & Code Reuse
9.  Plugins — must-have list & uses
10. Integrations (SCM, Build tools, Test, Artifacts, Cloud, Containers)
11. Credentials & Secrets Management
12. Security Hardening & Authentication/Authorization
13. Configuration as Code (JCasC), Job DSL & Automation
14. Backup, Restore & Disaster Recovery
15. Monitoring, Metrics & Performance Tuning
16. Scalability, Autoscaling Agents & Running on Kubernetes
17. CI/CD Patterns & Deployment Strategies
18. Troubleshooting — Common Issues & Fixes
19. Administration Tips & Useful Commands
20. Best Practices, Conventions & Policies
21. Example Jenkinsfiles (multiple languages & flows)
22. Useful Plugins Table (short)
23. Appendix: Groovy snippets, CLI examples, Backup script
24. Further Reading / References
----------------------------------------------------------------

1) INTRODUCTION & HISTORY
----------------------------------------------------------------
- Jenkins is an open-source automation server originally forked from
  Hudson in 2011. It is written in Java and designed to automate building,
  testing, and deploying software (CI/CD).
- Strong plugin ecosystem (thousands of community plugins) makes Jenkins
  extremely extensible and adaptable for many toolchains and workflows.
- Use cases: CI, CD, release orchestration, scheduled automation tasks, infra
  provisioning (via jobs/pipelines), and report aggregation.

2) KEY CONCEPTS & TERMINOLOGY
----------------------------------------------------------------
- JENKINS_HOME: main directory where Jenkins stores all configuration,
  jobs, plugins, credentials, secret keys, and build workspaces. Common path:
  /var/lib/jenkins (Linux packages) or a custom path when running from WAR.
- Controller (formerly "master"): central server that schedules jobs, hosts
  UI, stores config, and coordinates agents.
- Agent (node/slave): a machine (physical/VM/container) that executes build
  tasks when assigned by the controller.
- Executor: a slot on an agent/controller that runs one build at a time;
  an agent can have multiple executors.
- Job/Project: a configuration that describes how to build/test/deploy.
- Pipeline: a job type representing a whole CI/CD workflow defined as code
  (Jenkinsfile), two styles: Declarative & Scripted (Groovy).
- Workspace: filesystem location where a job runs and where source is checked out.
- Artifacts: produced build outputs (e.g., jars, binaries) that can be archived.
- Plugins: extension packages that add features — SCM integrations, build
  steps, notifications, etc.

3) ARCHITECTURE — CONTROLLER & AGENTS
----------------------------------------------------------------
- Controller responsibilities:
  - Manage configuration, build queue and schedules
  - Dispatch builds to agents
  - Serve UI, REST API, plugin management, credentials store
  - Persist build logs, artifacts, and history in JENKINS_HOME
- Agent types & connection modes:
  - SSH agents (controller connects via SSH)
  - JNLP/Remoting agents (agent initiates connection, used widely for dynamic agents)
  - Docker-based agents (agent runs inside container)
  - Kubernetes agents (ephemeral pods per build)
- Communication:
  - Uses the Jenkins Remoting library for controller-agent communication;
    more recent Kubernetes and container approaches prefer ephemeral pod agents.
- High-level scaling model:
  - Keep controller lightweight (1-2 executors recommended for controller)
  - Offload builds to many agents; scale agents horizontally for parallelism.
  - Use ephemeral agents (Docker/Kubernetes) to avoid stateful, long-lived agents.

4) INSTALLATION & PRODUCTION DEPLOYMENT OPTIONS
----------------------------------------------------------------
A. Quick options (dev/test):
   - Run via Docker image: `docker run -d -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts`
   - Run the Jenkins WAR with `java -jar jenkins.war` (not ideal for prod)

B. Ubuntu / Debian (APT package):
   - Install Java (recommended OpenJDK 11 or 17 depending on Jenkins LTS version)
   - Add Jenkins apt repository, apt-get install jenkins
   - Start/enable service with systemd

C. RHEL/CentOS:
   - Install Java, import RPM repository, install jenkins rpm
   - Use systemctl to manage service

D. Windows:
   - Use official MSI installer or run WAR via Java; configure as Windows service

E. Containerized (recommended for cloud-native):
   - Docker: official images, can run on Docker Engine or compose
   - Kubernetes: run Jenkins controller as a Deployment/StatefulSet with a
     PVC for JENKINS_HOME. Use the official Helm chart or community charts.
   - Use a VPS / cloud-managed instance with PV (persistent volume) for JENKINS_HOME.

F. Production considerations:
   - Use a dedicated host for controller with persistent storage and regular backups
   - Use TLS/HTTPS for the web UI (reverse proxy like NGINX or use ingress)
   - Offload heavy work to agents (avoid many executors on controller)
   - Consider CloudBees or other enterprise offerings for HA controllers
   - Monitor disk space closely: builds and artifacts grow fast

5) CORE COMPONENTS & JOB TYPES
----------------------------------------------------------------
- Freestyle Project: classic configurable job; good for simple tasks; limited
  pipeline features.
- Pipeline: the modern approach; Jenkinsfile defines stages and steps as code.
- Multibranch Pipeline: automatically discovers branches and PRs in SCM;
  creates branch-specific pipelines from Jenkinsfile in each branch.
- Organization / GitHub Organization job: scans multiple repositories and
  creates jobs for each repo with Jenkinsfile.
- Matrix (multi-configuration) project: run same job across combinations
  (OS x JDK x environment).
- Folder: logical grouping of jobs; helpful for RBAC and organization.

6) JENKINS PIPELINES — OVERVIEW
----------------------------------------------------------------
- Two major styles:
  A. Declarative Pipeline — opinionated, structured, easier for most users.
  B. Scripted Pipeline — free-form Groovy, more powerful and flexible.
- Jenkinsfile: store pipeline as part of repo (recommended). Jenkins reads it
  and executes pipeline per branch/job.
- Pipeline features: parallel stages, durable execution across restarts,
  artifact archiving, test reporting, build promotion, and more.

7) PIPELINE SYNTAX REFERENCE & USAGE (DECLARATIVE HIGHLIGHTS)
----------------------------------------------------------------
Structure example (Declarative):
```
pipeline {
  agent { label 'linux && docker' }
  options { skipDefaultCheckout(true) timeout(time:60, unit:'MINUTES') }
  environment { MAVEN_OPTS='-Xmx1024m' }
  stages {
    stage('Checkout') { steps { checkout scm } }
    stage('Build') { steps { sh 'mvn -B -DskipTests clean package' } }
    stage('Test') { steps { sh 'mvn test'; junit 'target/surefire-reports/*.xml' } }
    stage('Docker Build & Push') {
      when { branch 'main' }
      steps {
        withCredentials([string(credentialsId: 'DOCKER_HUB_TOKEN', variable: 'TOKEN')]) {
          sh 'docker build -t myorg/myapp:${env.BUILD_NUMBER} .'
          sh 'echo "$TOKEN" | docker login -u myuser --password-stdin'
          sh 'docker push myorg/myapp:${env.BUILD_NUMBER}'
        }
      }
    }
  }
  post {
    always { archiveArtifacts artifacts: 'target/*.jar', fingerprint: true }
    success { echo 'Build OK' }
    failure { mail to: 'team@example.com', subject: "Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}" }
  }
}
```

Important Declarative blocks:
- `agent` — where to run (any, none, label, docker, dockerfile)
- `tools` — auto-install tool versions (e.g., maven, jdk)
- `environment` — env vars for all stages
- `parameters` — job input parameters (string, boolean, choice, credentials)
- `options` — e.g., `disableConcurrentBuilds()`, `buildDiscarder(logRotator(...))`
- `stages` / `stage` — pipeline steps group
- `steps` — commands executed inside a stage
- `post` — actions after stage or pipeline (always, success, failure, unstable)
- `when` — conditional execution (branch, expression, changeset, environment)

Scripted Pipeline key features:
- Built using Groovy script with `node` blocks
- More powerful DSL constructs and dynamic behavior
- Example:
```
node('linux') {
  stage('Checkout') { checkout scm }
  stage('Build') { sh './build.sh' }
  if (env.BRANCH_NAME == 'main') {
    stage('Deploy') { sh './deploy.sh' }
  }
}
```

8) SHARED LIBRARIES & CODE REUSE
----------------------------------------------------------------
- Purpose: share common pipeline code and steps across many repositories.
- Structure:
  - vars/ (global vars as simple Groovy scripts)
  - src/ (Groovy classes packaged by namespace)
  - resources/ (templates, files)
- Use with `@Library('my-shared-lib@master') _` or in global configuration as "Global Pipeline Libraries".
- Version control recommended (tag releases) and enforce stable APIs.
- Best practices: small focused library functions, unit-testable components,
  use semantic versioning, avoid exposing secrets via libraries.

9) PLUGINS — ESSENTIALS & MANAGEMENT
----------------------------------------------------------------
- Plugins extend Jenkins behavior. Keep plugins minimal and controlled.
- Plugin management:
  - Install via "Manage Jenkins" → "Manage Plugins"
  - Use CLI or JCasC for automated plugin installation
  - Watch plugin dependencies and compatibility before upgrades
- Important plugins (short list — expanded later):
  - Pipeline, Git, GitHub/GitLab, Blue Ocean, Docker pipeline, Kubernetes, Credentials Binding, Role-based Authorization Strategy, Matrix Authorization, Job DSL, Configuration as Code, SonarQube Scanner, JUnit, Email Extension, Slack Notification, Artifactory/Nexus integration

10) INTEGRATIONS (SCM, BUILD TOOLS, TESTING, ARTIFACTS & CLOUD)
----------------------------------------------------------------
- SCMs: Git (Git plugin), GitHub (webhooks), GitLab, Bitbucket
  - Use webhooks to trigger builds on PRs/commits for fast feedback
- Build tools: Maven, Gradle, npm, pip — use Pipeline steps to call build
- Test frameworks: JUnit, TestNG; use `junit` step to publish test reports
- Code quality: SonarQube scanner plugin with `withSonarQubeEnv` step
- Artifact repositories: Nexus/Artifactory; use plugins to push artifacts
- Container registries: Docker Hub, AWS ECR, GitHub Container Registry — authenticate with credentials and push images in pipeline
- Cloud providers: AWS, Azure, GCP plugins — provision agents, upload artifacts, run deployments
- Config management: Ansible, Terraform — call ansible-playbook, terraform in pipeline or use dedicated deployment jobs

11) CREDENTIALS & SECRETS MANAGEMENT
----------------------------------------------------------------
- Jenkins credentials store supports:
  - Username with password
  - Secret text
  - SSH private keys
  - Secret file
  - Certificate credentials
- Use **Credentials Binding Plugin** to inject secrets into environment variables for pipelines.
- Avoid checking secrets into SCM; use credentials by ID and withCredentials block in pipeline.
- Important notes:
  - Credentials are stored encrypted on disk in JENKINS_HOME/credentials.xml and in secrets/
  - Always limit who can view or modify credentials (RBAC)
  - Consider external secret managers (Vault, AWS Secrets Manager) integrated via plugins or external script

12) SECURITY HARDENING & AUTHN/AUTHZ
----------------------------------------------------------------
- Use HTTPS for Jenkins UI and API (set up SSL on reverse proxy or with built-in settings)
- Disable anonymous access; use appropriate authentication (LDAP/AD, SSO/SAML/OpenID Connect)
- Use Role-based Authorization Strategy plugin for fine-grained RBAC
- Use Matrix-based security to explicitly assign permissions
- Lock down script console usage; audit groovy scripts and approvals
- Use CSP headers and disable unsafe plugins
- Keep Jenkins and plugins up to date to patch vulnerabilities
- Audit & logging:
  - Install Audit Trail, JobConfigHistory plugins to record configuration changes
  - Use centralized logging (ELK) and monitor for suspicious activity

13) CONFIGURATION AS CODE (JCasC) & JOB DSL
----------------------------------------------------------------
- JCasC plugin allows expressing Jenkins system configuration in YAML — useful for reproducible Jenkins system state in infrastructure as code.
- Job DSL enables programmatic creation of jobs using Groovy scripts; useful for templating job configurations.
- Workflow:
  - Keep JCasC YAML in Git and apply during bootstrap (init container or provisioning scripts)
  - Use Job DSL jobs or seed job to create application jobs
- Benefits: reproducibility, versioning, peer-review for config changes

14) BACKUP, RESTORE & DISASTER RECOVERY
----------------------------------------------------------------
- What to backup regularly:
  - JENKINS_HOME directory (config.xml, jobs/, plugins/, secrets/, credentials.xml, users/)
  - List of installed plugins (pluginVersions), custom scripts, and system groovy scripts
  - External: artifact repos, build machines, PV snapshots for Kubernetes
- Backup strategies:
  - VM snapshotting / PV snapshot (cloud provider snapshot)
  - Periodic tar/gzip of JENKINS_HOME to remote storage (S3/NFS)
  - Use backup plugins: thinBackup, SCM Sync Configuration (careful with plugin compatibility)
- Restore:
  - Stop Jenkins, restore JENKINS_HOME from backup, ensure permissions, start Jenkins
  - Validate plugin versions are compatible with restored state
- Example backup script (appendix includes a sample tar script)

15) MONITORING, METRICS & PERFORMANCE TUNING
----------------------------------------------------------------
- Monitor: disk usage, CPU, memory, number of builds, executor utilization, queue length
- Metrics plugins: Prometheus metrics plugin (export data), monitoring via Grafana
- Logs: configure log rotation, ship logs to ELK or similar
- JVM tuning: set proper heap size (-Xmx), configure GC flags, monitor GC pauses
- Tune executors carefully: controller recommended 0-2 executors; agents take the load
- Use workspace cleanup steps or `Workspace Cleanup Plugin` to avoid disk growth
- Use node labels and resource tagging so heavy builds go to properly provisioned agents

16) SCALABILITY, AGENT AUTOSCALING & KUBERNETES
----------------------------------------------------------------
- Approaches:
  - Static agents for stable, long-running builds
  - Dynamic agents: create agents on demand using Docker agents, EC2 plugin, or Kubernetes plugin
- Kubernetes plugin:
  - Launch ephemeral agent pods per build; podTemplate defines container image and volumes
  - Great for containerized builds and isolating builds per-run
- Use cloud provider autoscalers to scale worker pools automatically
- Use separate executors for different workloads (e.g., windows agents for windows-specific builds)

17) CI/CD PATTERNS & DEPLOYMENT STRATEGIES
----------------------------------------------------------------
- Git branch strategies: trunk-based, feature-branch with short life
- PR validation: build & test on PRs before merge
- Trunk-based & feature toggles enable continuous delivery
- Deployment strategies:
  - Rolling updates
  - Blue/Green deployments
  - Canary releases (canary traffic routing via service mesh like Istio)
  - Immutable artifact promotion (build once, deploy everywhere using the same artifact)
- Promotion process:
  - Use multi-stage pipeline: build -> test -> security/quality -> promote to staging -> manual approval -> production

18) TROUBLESHOOTING — COMMON ISSUES & FIXES
----------------------------------------------------------------
- Agent offline: check agent logs, firewall, correct Java version, mismatched remoting versions
- Out of disk space: clean workspaces, rotate artifacts, expand disk, move workspace to larger disk
- Long GC pauses / OOM: increase heap (-Xmx), tune GC, limit builds per agent, avoid large in-memory steps
- Slow UI: too many builds or plugins, consider archiving older builds, prune job histories
- Plugin compatibility errors after upgrade: keep plugin versions compatible, test upgrades on staging
- Credentials errors: verify credential IDs, correct scopes, and binding blocks

19) ADMINISTRATION TIPS & USEFUL COMMANDS
----------------------------------------------------------------
- Jenkins safe restart: `/safeRestart` (via CLI or REST) — waits for builds to finish
- Reload configuration from disk: `/reload` or "Reload from Disk" button
- CLI usage example:
  - `java -jar jenkins-cli.jar -s https://jenkins.example.com/ help`
  - Create job: `create-job test < config.xml`
  - Get job config: `get-job myjob > config.xml`
- Groovy script console is powerful; restrict access
- Manage plugins from CLI or via the `pluginManager` groovy API
- Export list of plugins and versions: useful for backup and recreation

20) BEST PRACTICES, CONVENTIONS & POLICIES
----------------------------------------------------------------
- Always version Jenkins system configuration (JCasC) and shared libraries in Git.
- Keep `Jenkinsfile` with repository; prefer Declarative pipeline for clarity.
- Use ephemeral containerized agents for isolation and reproducibility.
- Keep controller minimal — agents do the heavy lifting.
- Automated plugin management via IaC for reproducible Jenkins instances.
- Enforce branch and pipeline policies (e.g., unit tests, linting, security scans) for PRs.
- Limit permissions and use roles/scopes for credentials and job modification.

21) EXAMPLE JENKINSFILES (multiple patterns)
----------------------------------------------------------------
A. Simple Maven (Declarative)
```
pipeline {
  agent any
  tools { maven 'Maven 3.6.3' }
  stages {
    stage('Checkout') { steps { checkout scm } }
    stage('Build') { steps { sh 'mvn -B -DskipTests clean package' } }
    stage('Unit Test') { steps { sh 'mvn test'; junit 'target/surefire-reports/*.xml' } }
    stage('Archive') { steps { archiveArtifacts artifacts: 'target/*.jar', fingerprint: true } }
  }
  post { always { junit 'target/surefire-reports/*.xml' } }
}
```

B. Node.js (with caching & artifact publishing)
```
pipeline {
  agent { label 'nodejs' }
  environment { NPM_CONFIG_CACHE = "${WORKSPACE}/.npm" }
  stages {
    stage('Install') { steps { sh 'npm ci' } }
    stage('Test') { steps { sh 'npm test'; junit 'reports/**/*.xml' } }
    stage('Build') { steps { sh 'npm run build' } }
    stage('Publish') { when { branch 'main' } steps {
        withCredentials([string(credentialsId: 'NPM_TOKEN', variable: 'NPM_TOKEN')]) {
          sh 'echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > .npmrc'
          sh 'npm publish --access=public'
        }
      }
    }
  }
}
```

C. Docker Build & Push (declarative + Docker pipeline)
```
pipeline {
  agent any
  environment { IMAGE = "myorg/myapp:${env.BUILD_NUMBER}" }
  stages {
    stage('Checkout') { steps { checkout scm } }
    stage('Build Docker') {
      steps {
        script {
          docker.build("${env.IMAGE}", ".")
        }
      }
    }
    stage('Push') {
      when { branch 'main' }
      steps {
        withCredentials([usernamePassword(credentialsId: 'dockerhub', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
          sh 'echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin'
          sh 'docker push ${IMAGE}'
        }
      }
    }
  }
}
```

D. Multi-branch + PR builder: use Multibranch Pipeline job; add webhooks at SCM.

22) USEFUL PLUGINS (SHORT TABLE)
----------------------------------------------------------------
- Pipeline: core pipeline runtime
- Git: git SCM support
- GitHub Branch Source / GitLab Branch Source: auto branch detection
- Blue Ocean: modern pipeline UI
- Credentials Binding: inject credentials into build environments
- Kubernetes: dynamic pod agents
- Docker Pipeline: build/push docker images inside pipelines
- JUnit: test report publication
- SonarQube Scanner: code quality gates
- Job DSL: create jobs programmatically
- Configuration as Code: define Jenkins config in YAML
- Role-based Authorization Strategy: RBAC
- Email Extension & Slack Notification: notifications
- Prometheus Metrics: monitoring
- JobConfigHistory: configuration change history
- ThinBackup / S3 backup plugins: backup helpers

23) APPENDIX: GROOVY SNIPPETS, CLI, & BACKUP SCRIPT
----------------------------------------------------------------
A. Groovy snippet — list all jobs:
```
Jenkins.instance.getAllItems().each { println it.fullName }
```

B. Backup script (simple tar)
```
#!/bin/bash
TIMESTAMP=$(date +%F_%H%M%S)
JENKINS_HOME="/var/lib/jenkins"
BACKUP_DIR="/var/backups/jenkins"
mkdir -p "$BACKUP_DIR"
tar -czvf "${BACKUP_DIR}/jenkins-backup-${TIMESTAMP}.tar.gz" -C "$JENKINS_HOME" .
# Optionally upload to S3 using aws cli
# aws s3 cp ${BACKUP_DIR}/jenkins-backup-${TIMESTAMP}.tar.gz s3://my-jenkins-backups/
```

C. CLI example to create job:
```
java -jar jenkins-cli.jar -s http://jenkins:8080/ -auth admin:token create-job myjob < config.xml
```

24) FURTHER READING
----------------------------------------------------------------
- Official Jenkins docs: https://www.jenkins.io/
- Jenkins Pipeline Syntax reference (search "Pipeline Syntax" in Jenkins UI)
- Jenkins Configuration as Code plugin docs
- Kubernetes plugin docs (for running agents)
- Shared libraries & Pipeline Unit testing guides

----------------------------------------------------------------
END OF DOCUMENT
----------------------------------------------------------------
Notes:
- This document is designed to be self-contained and pragmatic for DevOps use.
- It includes commands and pipeline snippets you can copy-paste. Replace placeholders (credentials IDs, image names, hosts) with your values.
- If you want this broken into a PDF, Markdown, or a set of smaller files (plugins list, Jenkinsfile examples, backup utilities), tell me which format and I will generate them too.
