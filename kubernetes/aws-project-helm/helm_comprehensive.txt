
# Helm - Comprehensive Guide with Real-Time Examples

## 1. What is Helm?
Helm is the **package manager for Kubernetes**. It allows developers and operators to define, install, and upgrade even the most complex Kubernetes applications.  
Helm bundles multiple YAML manifests (Deployments, Services, ConfigMaps, etc.) into **charts** which can be easily reused across environments.

---

## 2. Helm Key Concepts

1. **Chart** → A Helm package that contains templates and configurations.  
2. **Release** → A running instance of a chart in a cluster.  
3. **Repository** → A collection of charts (e.g., Bitnami, ArtifactHub).  
4. **Values** → Configuration values that parameterize templates.  
5. **Templates** → YAML manifests with placeholders that get filled using values.  

---

## 3. Helm Chart Structure

When you create a chart (`helm create mychart`), you get:

```
mychart/
├── Chart.yaml        # Metadata about the chart
├── values.yaml       # Default values for the chart
├── templates/        # Template files for Kubernetes manifests
│   ├── deployment.yaml
│   ├── service.yaml
│   └── _helpers.tpl
├── charts/           # Subcharts (dependencies)
└── .helmignore       # Files ignored when packaging
```

### 3.1 Chart.yaml – Important Components
```yaml
apiVersion: v2                # API version of Helm
name: mychart                 # Name of the chart
description: A Helm chart for NGINX
type: application             # 'application' or 'library'
version: 0.1.0                # Version of this chart
appVersion: "1.25.0"          # Version of the app being deployed
maintainers:                  # Maintainer info
  - name: DevOps Team
    email: devops@company.com
keywords:
  - webserver
  - nginx
dependencies:                 # Optional dependencies
  - name: mysql
    version: 8.8.8
    repository: "https://charts.bitnami.com/bitnami"
```

### 3.2 values.yaml – Important Components
```yaml
replicaCount: 2

image:
  repository: nginx
  tag: "1.25"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: nginx
  hosts:
    - host: myapp.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

resources:                     # Resource requests & limits
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

nodeSelector: {}                # Node affinity
tolerations: []
affinity: {}
```

---

## 4. Helm Commands (Most Important)

- **Add repository**
  ```bash
  helm repo add bitnami https://charts.bitnami.com/bitnami
  helm repo update
  ```

- **Search for charts**
  ```bash
  helm search repo nginx
  ```

- **Install chart**
  ```bash
  helm install my-nginx bitnami/nginx
  ```

- **Install with values override**
  ```bash
  helm install my-nginx bitnami/nginx -f custom-values.yaml
  helm install my-nginx bitnami/nginx --set replicaCount=3,image.tag=1.26
  ```

- **List releases**
  ```bash
  helm list
  ```

- **Upgrade chart**
  ```bash
  helm upgrade my-nginx bitnami/nginx --set replicaCount=5
  ```

- **Rollback release**
  ```bash
  helm rollback my-nginx 1
  ```

- **Uninstall release**
  ```bash
  helm uninstall my-nginx
  ```

- **Dry-run (preview manifests)**
  ```bash
  helm install my-nginx bitnami/nginx --dry-run --debug
  ```

- **Template rendering (generate YAML without installing)**
  ```bash
  helm template my-nginx ./mychart
  ```

---

## 5. Real-Time Example – Without Helm vs With Helm

### 5.1 Normal Kubernetes Deployment (without Helm)
deployment.yaml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.25
        ports:
        - containerPort: 80
```

service.yaml
```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  type: ClusterIP
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
```

Problem → If we want to change replicas or image version, we must manually edit both files.

---

### 5.2 Same Deployment using Helm Templates

**values.yaml**
```yaml
replicaCount: 2
image:
  repository: nginx
  tag: "1.25"
service:
  type: ClusterIP
  port: 80
```

**templates/deployment.yaml**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}-nginx
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ .Release.Name }}
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}
    spec:
      containers:
        - name: nginx
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          ports:
            - containerPort: {{ .Values.service.port }}
```

**templates/service.yaml**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ .Release.Name }}-service
spec:
  type: {{ .Values.service.type }}
  selector:
    app: {{ .Release.Name }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: {{ .Values.service.port }}
```

✅ With Helm, you just update `values.yaml` or use `--set` flag. The templates automatically render new manifests.

---

## 6. Advanced Helm Features

1. **Hooks** → Run jobs at different lifecycle events (pre-install, post-install, pre-upgrade, etc.).  
2. **Dependencies** → Charts can include subcharts (e.g., app chart + MySQL chart).  
3. **Helmfile** → Manage multiple Helm releases in one place.  
4. **Secrets Management** → Integrate with external secret stores.  
5. **CI/CD Integration** → Helm is widely used in GitOps workflows with ArgoCD/FluxCD.

---

## 7. Real-Time Use Cases

- Deploying **Prometheus & Grafana** stack via Helm.  
- Installing **Databases (Postgres, MySQL, MongoDB)** using official charts.  
- Multi-environment deployments (dev, staging, prod) using different values files.  
- Cloud-native CI/CD pipelines (Helm integrated with GitHub Actions, Jenkins, ArgoCD).  

---

## 8. Summary

- Helm = Kubernetes package manager.  
- **Chart.yaml** → Metadata about chart.  
- **values.yaml** → Default configuration values.  
- **templates/** → Parameterized Kubernetes YAML files.  
- **Commands** → Install, upgrade, rollback, uninstall, dry-run, template.  
- Real-world benefit = reusable, versioned, configurable deployments.

