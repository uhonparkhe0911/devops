KUBERNETES TAINTS AND TOLERATIONS - COMPLETE DOCUMENTATION
==========================================================

1. Introduction
---------------
In Kubernetes, scheduling is the process of deciding which Pod runs on which Node. 
By default, Kubernetes aims to balance workloads across all available nodes. 
However, in real-world DevOps scenarios, we often need more control over workload placement.

Taints and Tolerations provide a mechanism to influence scheduling behavior, allowing 
operators to dedicate or restrict workloads to specific nodes.

- **Taint**: Applied on nodes, acts like a 'repellent' to pods.
- **Toleration**: Applied on pods, acts like an 'exception' that allows them to bypass taints.

This mechanism ensures that only the intended workloads run on specific nodes.

----------------------------------------------------------

2. Taints
---------
Taints are applied to nodes and prevent pods from being scheduled on them, unless 
those pods have a matching toleration.

### Syntax:
    kubectl taint nodes <node-name> key=value:effect

### Effects:
- **NoSchedule**: Pods without toleration will not be scheduled on the node.
- **PreferNoSchedule**: Scheduler avoids the node if possible, but may still place pods.
- **NoExecute**: New pods without toleration are not scheduled AND existing pods 
  without toleration are evicted.

### Example:
    kubectl taint nodes worker1 dedicated=frontend:NoSchedule

This means only pods that tolerate the 'dedicated=frontend:NoSchedule' taint can run on 'worker1'.

----------------------------------------------------------

3. Tolerations
--------------
Tolerations are applied to pods. They allow pods to run on nodes with matching taints.

### Example Pod YAML with Toleration:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: frontend-pod
spec:
  tolerations:
  - key: "dedicated"
    operator: "Equal"
    value: "frontend"
    effect: "NoSchedule"
  containers:
  - name: nginx
    image: nginx
```

This pod can be scheduled on nodes tainted with 'dedicated=frontend:NoSchedule'.

----------------------------------------------------------

4. Matching Rules
-----------------
- A toleration matches a taint if:
  - The keys are the same.
  - The operator condition matches.
  - The values are equal (if operator=Equal).
  - The effect is the same.

Notes:
- Tolerations DO NOT force scheduling onto a node, they only REMOVE restrictions.
- Scheduler still considers other factors like resources, affinity, etc.

----------------------------------------------------------

5. Practical Use Cases
----------------------
1. **Dedicated Nodes for Specific Workloads**
   - Example: DB pods on dedicated DB nodes.
   ```bash
   kubectl taint nodes db-node role=db:NoSchedule
   ```
   - Add toleration to DB pods.

2. **Special Hardware Workloads (GPU/SSD)**
   - Taint GPU nodes with: `gpu=true:NoSchedule`
   - Allow ML pods with toleration to use them.

3. **System Pods (Logging, Monitoring, Security Agents)**
   - Separate infra-level pods from application workloads.

4. **Eviction with NoExecute**
   - Evict pods from unhealthy nodes:
   ```bash
   kubectl taint nodes node1 status=unhealthy:NoExecute
   ```

5. **Node Maintenance**
   - Taint node before maintenance to drain pods safely.

----------------------------------------------------------

6. Combining Taints with Node Affinity
--------------------------------------
- **Taints + Tolerations**: Block nodes unless explicitly tolerated.
- **Node Affinity/Selector**: Force pods to prefer or require specific nodes.

Used together:
- Provide fine-grained control.
- Ensure correct pod placement and isolation.

----------------------------------------------------------

7. Commands Reference
---------------------
- Add a taint:
  ```bash
  kubectl taint nodes node1 key=value:NoSchedule
  ```
- Remove a taint:
  ```bash
  kubectl taint nodes node1 key:NoSchedule-
  ```
- List taints on a node:
  ```bash
  kubectl describe node node1 | grep Taints
  ```

----------------------------------------------------------

8. Best Practices
-----------------
- Use taints to **dedicate nodes** to critical workloads.
- Always pair taints with tolerations in manifests for clarity.
- Avoid excessive taints to prevent scheduling bottlenecks.
- Combine with **Node Affinity** for maximum scheduling control.
- Use **NoExecute** cautiously, as it can cause immediate eviction.

----------------------------------------------------------

9. Real-World Scenarios
-----------------------
- **GKE/EKS/AKS Reserved Nodes**: Managed Kubernetes often taints system nodes so 
  user workloads are not scheduled there.
- **GPU Nodes in ML Clusters**: Only ML workloads tolerate GPU taints.
- **Compliance/Security Isolation**: Sensitive workloads run on tainted secure nodes.

----------------------------------------------------------

10. Summary
-----------
- Taints = Restrictions on nodes.
- Tolerations = Exceptions for pods.
- Together, they provide **powerful workload placement control** in Kubernetes clusters.

